# 控制器系统（Controller System）

在现代游戏架构中，“控制器”承担了**行为驱动器**的角色，是实现数据驱动开发模式的核心要素。

---

## 💡 控制器的哲学：数据驱动 vs 传统面向对象

在传统的面向对象（OOP）设计中，一个类通常同时持有数据（成员变量）和行为（成员函数），听起来合理，却在大型项目中暴露出结构臃肿、耦合过重等问题。  
举个例子，`Player` 类既包含位置、生命值，又包含移动、攻击等行为，这使得行为无法轻易复用、测试、替换或动态切换。

为此，现代游戏架构逐渐转向**数据与行为解耦**的设计方式，通常采用如下方式：

| 项目        | 面向对象风格             | 数据驱动风格                     |
|-----------|---------------------|-----------------------------|
| 数据定义    | 数据与行为混杂在类内部       | 仅定义属性，不包含行为               |
| 行为执行者   | 类的成员函数             | 独立控制器对象，通过数据指针操作目标对象 |
| 行为绑定方式 | 隐式绑定              | 显式注入（通过传参绑定）            |
| 扩展性/维护性 | 差，易受破坏             | 高，可插拔、可测试、易扩展           |

> ✅ 结论：控制器负责**调度行为**，数据组件负责**存储状态**，两者职责单一、互不干扰，最终形成灵活、高内聚、低耦合的系统。

---

## 🧱 控制器系统的结构划分

| 模块         | 职责                         |
|------------|----------------------------|
| 实体对象（Actor） | 数据容器，表示游戏世界中的“存在”           |
| 控制器（Controller） | 行为驱动器，执行操作并修改实体对象的状态         |
| 组件（Component） | 功能片段，可绑定到实体上（如 CameraComponent） |
| 控制器映射系统     | 将用户输入映射到控制器操作上              |

---

## 🎥 摄像机控制器（Camera Controller）

摄像机（Camera）本质上只是一个“眼睛”组件，用于定义“从哪里看、看向哪里、怎么投影”。它本身不具备感知和行为能力。  
为了让它“动起来”，我们需要摄像机控制器模块。

### ✅ 为什么摄像机是组件？

- 它必须**附着到某个实体**（如玩家、观察点）
- 它本身仅包含视图和投影参数
- 它不是一个自我驱动的行为对象

### ✅ 为什么控制器要分离？

- 不同摄像机行为可以复用不同控制器（如第一人称、第三人称、飞行模式）
- 控制器中含有诸如 `Yaw/Pitch`, `MoveSpeed`, `Sensitivity` 等行为状态
- 避免让 Camera 变得臃肿

### ✅ 控制器常见职责

| 职责           | 示例 |
|--------------|------|
| 处理输入         | 响应键盘 WASD、鼠标移动 |
| 更新方向向量       | 根据 Yaw/Pitch 计算视线 |
| 更新摄像机位置/目标点 | 调用 `Camera::SetEye/SetTarget` |
| 控制移动/旋转速度    | 基于时间增量平滑移动 |

---

## 🧠 控制器与组件的插拔性原则

> 控制器应服务于组件，而非与组件耦死。

这意味着：

- 控制器应接收目标组件的引用或指针
- 控制器应尽量独立于具体实现，只操作公共接口
- 控制器可被动态替换（例如切换视角时更换控制器）
- 控制器之间应可组合（例如飞行+第一人称）

---

## 🧩 设计建议

- 控制器类中可以拥有行为相关的**状态属性**（如角度、速度），这些不属于组件。
- 组件类只维护**纯粹的状态数据**，并暴露接口供控制器调用。
- 控制器类中**不得直接访问成员变量**，一律通过接口操作组件，保持封装性。

---

## 🧪 示例场景：第一人称摄像机

```cpp
// 控制器更新逻辑（行为层）
void FirstPersonCameraController::Update(float deltaTime)
{
    float dx = input.GetAxis("LookRight");
    float dy = input.GetAxis("LookUp");
    yaw += dx * sensitivity;
    pitch += dy * sensitivity;
    pitch = glm::clamp(pitch, -PI/2, PI/2);

    glm::vec3 eye = camera->GetEye();
    glm::vec3 direction = ... // 使用 yaw/pitch 计算方向
    camera->SetTarget(eye + direction);
}
```

## 📌 小结
控制器是行为的调度者，组件是数据的持有者

控制器中定义“怎么做”，组件中定义“做了之后的状态”

控制器可热插拔、替换、组合，组件可复用、共享、配置

控制器应按需拥有行为状态字段，但不能擅自维护组件内部状态

>“控制器让数据活起来，组件让行为有依托。”

你可以想象整个游戏世界是一幅静态画卷，而控制器是赋予它灵魂的那只手。

---

实际问题示例：视图矩阵和投影矩阵的计算函数应该放在摄像机模块还是摄像机控制器模块?
> 因为这是摄像机自身属性的直接表达式，应该放在摄像机中。控制器是通过外部的输入去修改对象的属性状态。

---
如果你觉得这份文档清晰、结构合理，可以直接保存为 `CameraController.md` 或加入你现有的文档系统中。当然你也可以继续补充例如第三人称、轨道控制器等变种。
